* Debug test scene crash.


* Progressive multijittered sample sequences dev app
** Optimize stratum picking using acceleration structure
** Is debug builds faster with arrays instead of vectors?

BACKLOG:
* Path regularization. Perhaps just by clamping roughness along a path and then relax pr iteration.
* OptiX 6.X and CUDA 10
** Use VS 2017.
*** Enable intrinsic functions and whole program optimization. (Test for convolution)
*** Disable security checks in release
*** Disable RTTI!!
*** https://blogs.msdn.microsoft.com/vcblog/2016/10/26/recommendations-to-speed-c-builds-in-visual-studio/
** Check if support for actual pixel formats and samplers instead of just types and channel count.
* Upgrade tinygltf (Draco support!) and other tinys.
* Upgrade CMake and use the native CUDA compilation. https://cmake.org/cmake/help/v3.12/module/FindCUDA.html
* GLFW 3.3 - Handle windows high DPI scaling. https://www.glfw.org/docs/latest/news.html#content_scale_33
* OptiX (filtering) backends
** Try OptiX AI denoiser
** Filter neighbouring light samples before reconstruction - Screen space photon mapping approach with MIS weights / Path filtering.
*** Output buffers: Material ID, texcoord, position, normal, ray dir, weight, light sample, indirect sample. Define for compressing directions and use half/byte for some values.
*** Output screen space sample based on path/BSDF PDF.
**** Perhaps select a vertex if the BSDF PDF is less than 1 / PI or maybe even a bit more. Then vertices are selected roughly proportional to how 'diffuse' they are.
**** Trace ray footprint by assuming the ray is a cone. Then use Distributions::Cone::CosTheta(float angle) to compute the angle of each new cone after an intersection and use that for the density estimation kernel bandwidth.
** Pass BSDF and light sample to the path tracing RGP and let it handle accumulated radiance.
* SDF shadows - check UE4
** http://kunzhou.net/2013/fur-rendering-tvcg.pdf
* SSAO
** Intensity should be relative to sample distance, not absolute distance intensity.
*** When hitting the screen space max radius then results should be independent of the world radius. Are they? Test scene with three 'infinite' walls.
** Try seeding with hilbert curve + hash from 'Stratified sampling for stochastic transparency'
* SSBN
** Bent normal
*** Path tracer backend (Also one for SSAO?)
*** For diffuse env map lookup.
*** For cones compute aparture from visibility
*** Intersect bent cone with light cone or distribution and bake into 3D LUT (GTSO)
* Add coat to the default material.
** http://jcgt.org/published/0003/04/03/paper-lowres.pdf and https://www.youtube.com/watch?v=4nKb9hRYbPA
** Or just add a GGX layer on top with an iridescence parameter (red and blue fresnel offset relative to green. [Specularity, iridescence)
* Normals revisited
** Offset slightly along the geometric normal as well? To avoid self shadowing and hard edges on tesselated balls.
*** Or perhaps offset along the incoming direction? That one should obviously not intersect anything else.
** Bump mapping
*** Filter bumpmap mipmaps using Toksvig05, SGGX or AGAA NDF construction.
*** Compute AO maps based on normal maps.
*** Warp the hemisphere by the shading normal, such that samples are always drawn in an unwarped hemisphere, but then warped such that <0,0,1> corresponds to the shading/bump normal direction and samples halfway between <0,0,1> and the border of the hemisphere will be warped to be halfway between the shading normal and hemisphere.
*** 'Fix' the normals at edges. Let the shading normal lerp towards the geometric normal at grazing angles. (Offset normal by -view_dir until the dot product is 0.)
*** Or warp the hemisphere by the shading normal, such that the hemisphere is turned into a cone that only grazes the surface. That way samples would need to be converted from hemisphere to cone and back again. Pro: No special casing on light / view direction. Con: Black surface when view dir is outside the cone.
** Perhaps just dim 'blocked' regions as they could be lit indirectly.
* BTDF
** Transmission factor. Use IOR computed from specularity.

libs
* TinyDNN
** Cat detection
** A neural algorithm of artistic style, Gatys et al, 2015
** Use a siamese network to detect individual predefined lego bricks. (As opposed to classifying all lego bricks for all pixels.) Perhaps use transfer learning on some face recognition net
* ReactPhysics or BulletPhyssics (or both)
* RtAudio wrapper - https://github.com/thestk/rtaudio
* LuaJit - OpenSource (Fallback to interpretted Lua if the target architecture isn't supported.)