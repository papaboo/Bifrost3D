// Precompute the directional-hemispherical reflectance function (rho).
// ------------------------------------------------------------------------------------------------
// Copyright (C) Bifrost. See AUTHORS.txt for authors.
//
// This program is open source and distributed under the New BSD License.
// See LICENSE.txt for more detail.
// ------------------------------------------------------------------------------------------------

#ifndef _PRECOMPUTE_ROUGH_BRDF_RHO_H_
#define _PRECOMPUTE_ROUGH_BRDF_RHO_H_

#include <OptiXRenderer/Shading/BSDFs/GGX.h>
#include <OptiXRenderer/RNG.h>

#include <Bifrost/Assets/Image.h>
#include <Bifrost/Core/Array.h>
#include <Bifrost/Math/Utils.h>

#include <fstream>

namespace PrecomputeRoughBRDFRho {

using namespace Bifrost;
using namespace optix;
using namespace OptiXRenderer;

typedef BSDFSample(*SampleRoughBRDF)(float roughness, float3 wo, float2 random_sample);

double estimate_rho(float3 wo, float roughness, unsigned int sample_count, SampleRoughBRDF sample_rough_BSDF) {

    Core::Array<double> throughput = Core::Array<double>(sample_count);
    for (unsigned int s = 0; s < sample_count; ++s) {
        float2 rng_sample = RNG::sample02(s);
        BSDFSample sample = sample_rough_BSDF(roughness, wo, rng_sample);
        if (sample.PDF.is_valid())
            throughput[s] = sample.reflectance.x * sample.direction.z / sample.PDF.value();
        else
            throughput[s] = 0.0;
    }

    return Math::sort_and_pairwise_summation(throughput.begin(), throughput.end()) / sample_count;
}

Assets::Image estimate_rho(unsigned int width, unsigned int height, unsigned int sample_count, SampleRoughBRDF sample_rough_BSDF) {
    Assets::Image rho_image = Assets::Image::create2D("rho", Assets::PixelFormat::RGB_Float, 1.0f, Math::Vector2ui(width, height));
    Math::RGB* rho_image_pixels = rho_image.get_pixels<Math::RGB>();

#pragma omp parallel for
    for (int y = 0; y < int(height); ++y) {
        float roughness = y / float(height - 1);
        for (int x = 0; x < int(width); ++x) {
            float cos_theta = fmaxf(0.000001f, x / float(width - 1));
            float3 wo = make_float3(sqrt(1.0f - cos_theta * cos_theta), 0.0f, cos_theta);
            double rho = estimate_rho(wo, roughness, sample_count, sample_rough_BSDF);
            rho_image_pixels[x + y * width] = Math::RGB(float(rho));
        }
    }

    return rho_image;
}

std::string format_float(float v) {
    std::ostringstream out;
    out << v;
    if (out.str().length() == 1)
        out << ".0f";
    else
        out << "f";
    return out.str();
}

std::string get_rho_type(int dimensions) {
    std::ostringstream out;
    if (dimensions == 1)
        out << "float";
    else
        out << "Vector" << dimensions << "f";
    return out.str();
}

template <int ElementDimensions>
void output_brdf(Assets::Image image, int sample_count, const std::string& filename, const std::string& data_name, const std::string& description) {

    unsigned int width = image.get_width();
    unsigned int height = image.get_height();
    Math::RGB* image_pixels = image.get_pixels<Math::RGB>();

    std::string rho_type = get_rho_type(ElementDimensions);

    std::ofstream out_header(filename);
    out_header <<
        "// " << description << "\n"
        "// ------------------------------------------------------------------------------------------------\n"
        "// Copyright (C) 2018, Bifrost. See AUTHORS.txt for authors\n"
        "//\n"
        "// This program is open source and distributed under the New BSD License.\n"
        "// See LICENSE.txt for more detail.\n"
        "// ------------------------------------------------------------------------------------------------\n"
        "// Generated by MaterialPrecomputations application.\n"
        "// ------------------------------------------------------------------------------------------------\n"
        "\n"
        "#include <Bifrost/Assets/Shading/Fittings.h>\n"
        "#include <Bifrost/Math/Utils.h>\n"
        "\n";
    if (ElementDimensions > 1)
        out_header << "using Bifrost::Math::" << rho_type << ";\n\n";
    out_header <<
        "namespace Bifrost::Assets::Shading::Rho {\n"
        "\n";
    out_header << "const int " << data_name << "_sample_count = " << sample_count << "u;\n"
        "const int " << data_name << "_angle_sample_count = " << width << "u;\n"
        "const int " << data_name << "_roughness_sample_count = " << height << "u;\n"
        "\n"
        "const " << rho_type << " " << data_name << "[] = {\n";

    for (int y = 0; y < int(height); ++y) {
        float roughness = y / float(height - 1);
        out_header << "    // Roughness " << roughness << "\n";
        out_header << "    ";
        for (int x = 0; x < int(width); ++x) {
            Math::RGB& rho = image_pixels[x + y * width];
            if (ElementDimensions == 1)
                out_header << format_float(rho.r) << ", ";
            else if (ElementDimensions == 2)
                out_header << "Vector2f(" << format_float(rho.r) << ", " << format_float(rho.g) << "), ";
            else if (ElementDimensions == 3)
                out_header << "Vector3f(" << format_float(rho.r) << ", " << format_float(rho.g) << ", " << format_float(rho.b) << "), ";
        }
        out_header << "\n";
    }

    out_header <<
        "};\n"
        "\n"
        "" << rho_type << " sample_" << data_name << "(float wo_dot_normal, float roughness) {\n"
        "    using namespace Bifrost::Math;\n"
        "\n"
        "    float roughness_coord = roughness * (" << data_name << "_roughness_sample_count - 1);\n"
        "    int lower_roughness_row = int(roughness_coord);\n"
        "    int upper_roughness_row = min(lower_roughness_row + 1, " << data_name << "_roughness_sample_count - 1);\n"
        "\n"
        "    float wo_dot_normal_coord = wo_dot_normal * (" << data_name << "_angle_sample_count - 1);\n"
        "    int lower_wo_dot_normal_column = int(wo_dot_normal_coord);\n"
        "    int upper_wo_dot_normal_column = min(lower_wo_dot_normal_column + 1, " << data_name << "_angle_sample_count - 1);\n"
        "\n"
        "    // Interpolate by wo_dot_normal\n"
        "    float wo_dot_normal_t = wo_dot_normal_coord - lower_wo_dot_normal_column;\n"
        "    const " << rho_type << "* lower_rho_row = " << data_name << " + lower_roughness_row * " << data_name << "_roughness_sample_count;\n"
        "    " << rho_type << " lower_rho = lerp(lower_rho_row[lower_wo_dot_normal_column], lower_rho_row[upper_wo_dot_normal_column], wo_dot_normal_t);\n"
        "\n"
        "    const " << rho_type << "* upper_rho_row = " << data_name << " + upper_roughness_row * " << data_name << "_roughness_sample_count;\n"
        "    " << rho_type << " upper_rho = lerp(upper_rho_row[lower_wo_dot_normal_column], upper_rho_row[upper_wo_dot_normal_column], wo_dot_normal_t);\n"
        "\n"
        "    // Interpolate by roughness\n"
        "    float roughness_t = roughness_coord - lower_roughness_row;\n"
        "    return lerp(lower_rho, upper_rho, roughness_t);\n"
        "}\n"
        "\n"
        "} // NS Bifrost::Assets::Shading::Rho\n";

    out_header.close();
}

} // NS PrecomputeRoughBRDFRho

#endif // _PRECOMPUTE_ROUGH_BRDF_RHO_H_